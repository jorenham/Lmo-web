__all__ = 'WebLoop', 'WebLoopPolicy', 'PyodideFuture', 'PyodideTask'

import asyncio
from collections.abc import Awaitable, Callable
from typing import Any, Coroutine, TypeVar, overload

T = TypeVar('T')
S = TypeVar('S')

class PyodideFuture(asyncio.Future[T]):
    @overload
    def then(self, onfulfilled: None, onrejected: Callable[[BaseException], Awaitable[S]]) -> PyodideFuture[S]: ...
    @overload
    def then(self, onfulfilled: None, onrejected: Callable[[BaseException], S]) -> PyodideFuture[S]: ...
    @overload
    def then(self, onfulfilled: Callable[[T], Awaitable[S]], onrejected: Callable[[BaseException], Awaitable[S]] | None = ...) -> PyodideFuture[S]: ...
    @overload
    def then(self, onfulfilled: Callable[[T], S], onrejected: Callable[[BaseException], S] | None = ...) -> PyodideFuture[S]: ...
    @overload
    def catch(self, onrejected: Callable[[BaseException], Awaitable[S]]) -> PyodideFuture[S]: ...
    @overload
    def catch(self, onrejected: Callable[[BaseException], S]) -> PyodideFuture[S]: ...
    def finally_(self, onfinally: Callable[[], None]) -> PyodideFuture[T]: ...

class PyodideTask(asyncio.Task[T], PyodideFuture[T]): ...

class WebLoop(asyncio.AbstractEventLoop):
    def run_in_executor(self, executor, func: Callable[..., T], *args: Any) -> PyodideFuture[T]: ...
    def create_future(self) -> PyodideFuture[Any]: ...
    def create_task(self, coro: Coroutine[Any, None, T], *, name=...) -> PyodideTask[T]: ...  # type: ignore

class WebLoopPolicy(asyncio.DefaultEventLoopPolicy):
    def get_event_loop(self) -> WebLoop: ...
    def new_event_loop(self) -> WebLoop: ...
